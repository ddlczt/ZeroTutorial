// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: space_service.proto
// Protobuf C++ Version: 5.27.0

#ifndef GOOGLE_PROTOBUF_INCLUDED_space_5fservice_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_space_5fservice_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5027000
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_space_5fservice_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_space_5fservice_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_space_5fservice_2eproto;
namespace space_service {
class Animation;
struct AnimationDefaultTypeInternal;
extern AnimationDefaultTypeInternal _Animation_default_instance_;
class AoiPlayer;
struct AoiPlayerDefaultTypeInternal;
extern AoiPlayerDefaultTypeInternal _AoiPlayer_default_instance_;
class AttrSet;
struct AttrSetDefaultTypeInternal;
extern AttrSetDefaultTypeInternal _AttrSet_default_instance_;
class JoinReply;
struct JoinReplyDefaultTypeInternal;
extern JoinReplyDefaultTypeInternal _JoinReply_default_instance_;
class LoginReply;
struct LoginReplyDefaultTypeInternal;
extern LoginReplyDefaultTypeInternal _LoginReply_default_instance_;
class LoginRequest;
struct LoginRequestDefaultTypeInternal;
extern LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
class Movement;
struct MovementDefaultTypeInternal;
extern MovementDefaultTypeInternal _Movement_default_instance_;
class NormalAttack;
struct NormalAttackDefaultTypeInternal;
extern NormalAttackDefaultTypeInternal _NormalAttack_default_instance_;
class Ping;
struct PingDefaultTypeInternal;
extern PingDefaultTypeInternal _Ping_default_instance_;
class PlayerAnimation;
struct PlayerAnimationDefaultTypeInternal;
extern PlayerAnimationDefaultTypeInternal _PlayerAnimation_default_instance_;
class PlayerAttrSet;
struct PlayerAttrSetDefaultTypeInternal;
extern PlayerAttrSetDefaultTypeInternal _PlayerAttrSet_default_instance_;
class PlayerMovement;
struct PlayerMovementDefaultTypeInternal;
extern PlayerMovementDefaultTypeInternal _PlayerMovement_default_instance_;
class PlayerMovements;
struct PlayerMovementsDefaultTypeInternal;
extern PlayerMovementsDefaultTypeInternal _PlayerMovements_default_instance_;
class PlayersEnterSight;
struct PlayersEnterSightDefaultTypeInternal;
extern PlayersEnterSightDefaultTypeInternal _PlayersEnterSight_default_instance_;
class PlayersLeaveSight;
struct PlayersLeaveSightDefaultTypeInternal;
extern PlayersLeaveSightDefaultTypeInternal _PlayersLeaveSight_default_instance_;
class Pong;
struct PongDefaultTypeInternal;
extern PongDefaultTypeInternal _Pong_default_instance_;
class SkillAttack;
struct SkillAttackDefaultTypeInternal;
extern SkillAttackDefaultTypeInternal _SkillAttack_default_instance_;
class SkillInfo;
struct SkillInfoDefaultTypeInternal;
extern SkillInfoDefaultTypeInternal _SkillInfo_default_instance_;
class TakeDamage;
struct TakeDamageDefaultTypeInternal;
extern TakeDamageDefaultTypeInternal _TakeDamage_default_instance_;
class Vector3f;
struct Vector3fDefaultTypeInternal;
extern Vector3fDefaultTypeInternal _Vector3f_default_instance_;
}  // namespace space_service
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace space_service {
enum Animation_OperationType : int {
  Animation_OperationType_START = 0,
  Animation_OperationType_STOP = 1,
  Animation_OperationType_UPDATE = 2,
  Animation_OperationType_Animation_OperationType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Animation_OperationType_Animation_OperationType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Animation_OperationType_IsValid(int value);
extern const uint32_t Animation_OperationType_internal_data_[];
constexpr Animation_OperationType Animation_OperationType_OperationType_MIN = static_cast<Animation_OperationType>(0);
constexpr Animation_OperationType Animation_OperationType_OperationType_MAX = static_cast<Animation_OperationType>(2);
constexpr int Animation_OperationType_OperationType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
Animation_OperationType_descriptor();
template <typename T>
const std::string& Animation_OperationType_Name(T value) {
  static_assert(std::is_same<T, Animation_OperationType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to OperationType_Name().");
  return Animation_OperationType_Name(static_cast<Animation_OperationType>(value));
}
template <>
inline const std::string& Animation_OperationType_Name(Animation_OperationType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Animation_OperationType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool Animation_OperationType_Parse(absl::string_view name, Animation_OperationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Animation_OperationType>(
      Animation_OperationType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Vector3f final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:space_service.Vector3f) */ {
 public:
  inline Vector3f() : Vector3f(nullptr) {}
  ~Vector3f() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Vector3f(
      ::google::protobuf::internal::ConstantInitialized);

  inline Vector3f(const Vector3f& from) : Vector3f(nullptr, from) {}
  inline Vector3f(Vector3f&& from) noexcept
      : Vector3f(nullptr, std::move(from)) {}
  inline Vector3f& operator=(const Vector3f& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector3f& operator=(Vector3f&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vector3f& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vector3f* internal_default_instance() {
    return reinterpret_cast<const Vector3f*>(
        &_Vector3f_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Vector3f& a, Vector3f& b) { a.Swap(&b); }
  inline void Swap(Vector3f* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector3f* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vector3f* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Vector3f>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Vector3f& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Vector3f& from) { Vector3f::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Vector3f* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "space_service.Vector3f"; }

 protected:
  explicit Vector3f(::google::protobuf::Arena* arena);
  Vector3f(::google::protobuf::Arena* arena, const Vector3f& from);
  Vector3f(::google::protobuf::Arena* arena, Vector3f&& from) noexcept
      : Vector3f(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // float y = 2;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // float z = 3;
  void clear_z() ;
  float z() const;
  void set_z(float value);

  private:
  float _internal_z() const;
  void _internal_set_z(float value);

  public:
  // @@protoc_insertion_point(class_scope:space_service.Vector3f)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Vector3f_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Vector3f& from_msg);
    float x_;
    float y_;
    float z_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_space_5fservice_2eproto;
};
// -------------------------------------------------------------------

class TakeDamage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:space_service.TakeDamage) */ {
 public:
  inline TakeDamage() : TakeDamage(nullptr) {}
  ~TakeDamage() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TakeDamage(
      ::google::protobuf::internal::ConstantInitialized);

  inline TakeDamage(const TakeDamage& from) : TakeDamage(nullptr, from) {}
  inline TakeDamage(TakeDamage&& from) noexcept
      : TakeDamage(nullptr, std::move(from)) {}
  inline TakeDamage& operator=(const TakeDamage& from) {
    CopyFrom(from);
    return *this;
  }
  inline TakeDamage& operator=(TakeDamage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TakeDamage& default_instance() {
    return *internal_default_instance();
  }
  static inline const TakeDamage* internal_default_instance() {
    return reinterpret_cast<const TakeDamage*>(
        &_TakeDamage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(TakeDamage& a, TakeDamage& b) { a.Swap(&b); }
  inline void Swap(TakeDamage* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TakeDamage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TakeDamage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<TakeDamage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TakeDamage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TakeDamage& from) { TakeDamage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TakeDamage* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "space_service.TakeDamage"; }

 protected:
  explicit TakeDamage(::google::protobuf::Arena* arena);
  TakeDamage(::google::protobuf::Arena* arena, const TakeDamage& from);
  TakeDamage(::google::protobuf::Arena* arena, TakeDamage&& from) noexcept
      : TakeDamage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEidFieldNumber = 1,
    kDamageFieldNumber = 2,
  };
  // int32 eid = 1;
  void clear_eid() ;
  ::int32_t eid() const;
  void set_eid(::int32_t value);

  private:
  ::int32_t _internal_eid() const;
  void _internal_set_eid(::int32_t value);

  public:
  // int32 damage = 2;
  void clear_damage() ;
  ::int32_t damage() const;
  void set_damage(::int32_t value);

  private:
  ::int32_t _internal_damage() const;
  void _internal_set_damage(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:space_service.TakeDamage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_TakeDamage_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TakeDamage& from_msg);
    ::int32_t eid_;
    ::int32_t damage_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_space_5fservice_2eproto;
};
// -------------------------------------------------------------------

class SkillInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:space_service.SkillInfo) */ {
 public:
  inline SkillInfo() : SkillInfo(nullptr) {}
  ~SkillInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SkillInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline SkillInfo(const SkillInfo& from) : SkillInfo(nullptr, from) {}
  inline SkillInfo(SkillInfo&& from) noexcept
      : SkillInfo(nullptr, std::move(from)) {}
  inline SkillInfo& operator=(const SkillInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SkillInfo& operator=(SkillInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SkillInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SkillInfo* internal_default_instance() {
    return reinterpret_cast<const SkillInfo*>(
        &_SkillInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(SkillInfo& a, SkillInfo& b) { a.Swap(&b); }
  inline void Swap(SkillInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SkillInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SkillInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<SkillInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SkillInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SkillInfo& from) { SkillInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SkillInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "space_service.SkillInfo"; }

 protected:
  explicit SkillInfo(::google::protobuf::Arena* arena);
  SkillInfo(::google::protobuf::Arena* arena, const SkillInfo& from);
  SkillInfo(::google::protobuf::Arena* arena, SkillInfo&& from) noexcept
      : SkillInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSkillIdFieldNumber = 1,
    kNextCastTimeFieldNumber = 2,
    kCostManaFieldNumber = 3,
    kCoolDownFieldNumber = 4,
  };
  // int32 skill_id = 1;
  void clear_skill_id() ;
  ::int32_t skill_id() const;
  void set_skill_id(::int32_t value);

  private:
  ::int32_t _internal_skill_id() const;
  void _internal_set_skill_id(::int32_t value);

  public:
  // int32 next_cast_time = 2;
  void clear_next_cast_time() ;
  ::int32_t next_cast_time() const;
  void set_next_cast_time(::int32_t value);

  private:
  ::int32_t _internal_next_cast_time() const;
  void _internal_set_next_cast_time(::int32_t value);

  public:
  // optional int32 cost_mana = 3;
  bool has_cost_mana() const;
  void clear_cost_mana() ;
  ::int32_t cost_mana() const;
  void set_cost_mana(::int32_t value);

  private:
  ::int32_t _internal_cost_mana() const;
  void _internal_set_cost_mana(::int32_t value);

  public:
  // optional int32 cool_down = 4;
  bool has_cool_down() const;
  void clear_cool_down() ;
  ::int32_t cool_down() const;
  void set_cool_down(::int32_t value);

  private:
  ::int32_t _internal_cool_down() const;
  void _internal_set_cool_down(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:space_service.SkillInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SkillInfo_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SkillInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t skill_id_;
    ::int32_t next_cast_time_;
    ::int32_t cost_mana_;
    ::int32_t cool_down_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_space_5fservice_2eproto;
};
// -------------------------------------------------------------------

class SkillAttack final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:space_service.SkillAttack) */ {
 public:
  inline SkillAttack() : SkillAttack(nullptr) {}
  ~SkillAttack() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SkillAttack(
      ::google::protobuf::internal::ConstantInitialized);

  inline SkillAttack(const SkillAttack& from) : SkillAttack(nullptr, from) {}
  inline SkillAttack(SkillAttack&& from) noexcept
      : SkillAttack(nullptr, std::move(from)) {}
  inline SkillAttack& operator=(const SkillAttack& from) {
    CopyFrom(from);
    return *this;
  }
  inline SkillAttack& operator=(SkillAttack&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SkillAttack& default_instance() {
    return *internal_default_instance();
  }
  static inline const SkillAttack* internal_default_instance() {
    return reinterpret_cast<const SkillAttack*>(
        &_SkillAttack_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(SkillAttack& a, SkillAttack& b) { a.Swap(&b); }
  inline void Swap(SkillAttack* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SkillAttack* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SkillAttack* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<SkillAttack>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SkillAttack& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SkillAttack& from) { SkillAttack::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SkillAttack* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "space_service.SkillAttack"; }

 protected:
  explicit SkillAttack(::google::protobuf::Arena* arena);
  SkillAttack(::google::protobuf::Arena* arena, const SkillAttack& from);
  SkillAttack(::google::protobuf::Arena* arena, SkillAttack&& from) noexcept
      : SkillAttack(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSkillIdFieldNumber = 1,
  };
  // int32 skill_id = 1;
  void clear_skill_id() ;
  ::int32_t skill_id() const;
  void set_skill_id(::int32_t value);

  private:
  ::int32_t _internal_skill_id() const;
  void _internal_set_skill_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:space_service.SkillAttack)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SkillAttack_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SkillAttack& from_msg);
    ::int32_t skill_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_space_5fservice_2eproto;
};
// -------------------------------------------------------------------

class Pong final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:space_service.Pong) */ {
 public:
  inline Pong() : Pong(nullptr) {}
  ~Pong() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Pong(
      ::google::protobuf::internal::ConstantInitialized);

  inline Pong(const Pong& from) : Pong(nullptr, from) {}
  inline Pong(Pong&& from) noexcept
      : Pong(nullptr, std::move(from)) {}
  inline Pong& operator=(const Pong& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pong& operator=(Pong&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Pong& default_instance() {
    return *internal_default_instance();
  }
  static inline const Pong* internal_default_instance() {
    return reinterpret_cast<const Pong*>(
        &_Pong_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(Pong& a, Pong& b) { a.Swap(&b); }
  inline void Swap(Pong* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pong* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Pong* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Pong>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Pong& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Pong& from) { Pong::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Pong* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "space_service.Pong"; }

 protected:
  explicit Pong(::google::protobuf::Arena* arena);
  Pong(::google::protobuf::Arena* arena, const Pong& from);
  Pong(::google::protobuf::Arena* arena, Pong&& from) noexcept
      : Pong(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTFieldNumber = 1,
    kServerTFieldNumber = 2,
  };
  // float t = 1;
  void clear_t() ;
  float t() const;
  void set_t(float value);

  private:
  float _internal_t() const;
  void _internal_set_t(float value);

  public:
  // int32 server_t = 2;
  void clear_server_t() ;
  ::int32_t server_t() const;
  void set_server_t(::int32_t value);

  private:
  ::int32_t _internal_server_t() const;
  void _internal_set_server_t(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:space_service.Pong)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Pong_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Pong& from_msg);
    float t_;
    ::int32_t server_t_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_space_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PlayersLeaveSight final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:space_service.PlayersLeaveSight) */ {
 public:
  inline PlayersLeaveSight() : PlayersLeaveSight(nullptr) {}
  ~PlayersLeaveSight() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayersLeaveSight(
      ::google::protobuf::internal::ConstantInitialized);

  inline PlayersLeaveSight(const PlayersLeaveSight& from) : PlayersLeaveSight(nullptr, from) {}
  inline PlayersLeaveSight(PlayersLeaveSight&& from) noexcept
      : PlayersLeaveSight(nullptr, std::move(from)) {}
  inline PlayersLeaveSight& operator=(const PlayersLeaveSight& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayersLeaveSight& operator=(PlayersLeaveSight&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayersLeaveSight& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayersLeaveSight* internal_default_instance() {
    return reinterpret_cast<const PlayersLeaveSight*>(
        &_PlayersLeaveSight_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(PlayersLeaveSight& a, PlayersLeaveSight& b) { a.Swap(&b); }
  inline void Swap(PlayersLeaveSight* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayersLeaveSight* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayersLeaveSight* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PlayersLeaveSight>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayersLeaveSight& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayersLeaveSight& from) { PlayersLeaveSight::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlayersLeaveSight* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "space_service.PlayersLeaveSight"; }

 protected:
  explicit PlayersLeaveSight(::google::protobuf::Arena* arena);
  PlayersLeaveSight(::google::protobuf::Arena* arena, const PlayersLeaveSight& from);
  PlayersLeaveSight(::google::protobuf::Arena* arena, PlayersLeaveSight&& from) noexcept
      : PlayersLeaveSight(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPlayersFieldNumber = 1,
  };
  // repeated int32 players = 1;
  int players_size() const;
  private:
  int _internal_players_size() const;

  public:
  void clear_players() ;
  ::int32_t players(int index) const;
  void set_players(int index, ::int32_t value);
  void add_players(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& players() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_players();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_players() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_players();

  public:
  // @@protoc_insertion_point(class_scope:space_service.PlayersLeaveSight)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_PlayersLeaveSight_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PlayersLeaveSight& from_msg);
    ::google::protobuf::RepeatedField<::int32_t> players_;
    mutable ::google::protobuf::internal::CachedSize _players_cached_byte_size_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_space_5fservice_2eproto;
};
// -------------------------------------------------------------------

class Ping final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:space_service.Ping) */ {
 public:
  inline Ping() : Ping(nullptr) {}
  ~Ping() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Ping(
      ::google::protobuf::internal::ConstantInitialized);

  inline Ping(const Ping& from) : Ping(nullptr, from) {}
  inline Ping(Ping&& from) noexcept
      : Ping(nullptr, std::move(from)) {}
  inline Ping& operator=(const Ping& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ping& operator=(Ping&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ping& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ping* internal_default_instance() {
    return reinterpret_cast<const Ping*>(
        &_Ping_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(Ping& a, Ping& b) { a.Swap(&b); }
  inline void Swap(Ping* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ping* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ping* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Ping>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Ping& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Ping& from) { Ping::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Ping* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "space_service.Ping"; }

 protected:
  explicit Ping(::google::protobuf::Arena* arena);
  Ping(::google::protobuf::Arena* arena, const Ping& from);
  Ping(::google::protobuf::Arena* arena, Ping&& from) noexcept
      : Ping(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTFieldNumber = 1,
  };
  // float t = 1;
  void clear_t() ;
  float t() const;
  void set_t(float value);

  private:
  float _internal_t() const;
  void _internal_set_t(float value);

  public:
  // @@protoc_insertion_point(class_scope:space_service.Ping)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Ping_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Ping& from_msg);
    float t_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_space_5fservice_2eproto;
};
// -------------------------------------------------------------------

class NormalAttack final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:space_service.NormalAttack) */ {
 public:
  inline NormalAttack() : NormalAttack(nullptr) {}
  ~NormalAttack() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NormalAttack(
      ::google::protobuf::internal::ConstantInitialized);

  inline NormalAttack(const NormalAttack& from) : NormalAttack(nullptr, from) {}
  inline NormalAttack(NormalAttack&& from) noexcept
      : NormalAttack(nullptr, std::move(from)) {}
  inline NormalAttack& operator=(const NormalAttack& from) {
    CopyFrom(from);
    return *this;
  }
  inline NormalAttack& operator=(NormalAttack&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NormalAttack& default_instance() {
    return *internal_default_instance();
  }
  static inline const NormalAttack* internal_default_instance() {
    return reinterpret_cast<const NormalAttack*>(
        &_NormalAttack_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(NormalAttack& a, NormalAttack& b) { a.Swap(&b); }
  inline void Swap(NormalAttack* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NormalAttack* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NormalAttack* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NormalAttack>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NormalAttack& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NormalAttack& from) { NormalAttack::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NormalAttack* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "space_service.NormalAttack"; }

 protected:
  explicit NormalAttack(::google::protobuf::Arena* arena);
  NormalAttack(::google::protobuf::Arena* arena, const NormalAttack& from);
  NormalAttack(::google::protobuf::Arena* arena, NormalAttack&& from) noexcept
      : NormalAttack(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kComboFieldNumber = 1,
  };
  // int32 combo = 1;
  void clear_combo() ;
  ::int32_t combo() const;
  void set_combo(::int32_t value);

  private:
  ::int32_t _internal_combo() const;
  void _internal_set_combo(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:space_service.NormalAttack)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_NormalAttack_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const NormalAttack& from_msg);
    ::int32_t combo_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_space_5fservice_2eproto;
};
// -------------------------------------------------------------------

class LoginRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:space_service.LoginRequest) */ {
 public:
  inline LoginRequest() : LoginRequest(nullptr) {}
  ~LoginRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LoginRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline LoginRequest(const LoginRequest& from) : LoginRequest(nullptr, from) {}
  inline LoginRequest(LoginRequest&& from) noexcept
      : LoginRequest(nullptr, std::move(from)) {}
  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginRequest& operator=(LoginRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginRequest* internal_default_instance() {
    return reinterpret_cast<const LoginRequest*>(
        &_LoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(LoginRequest& a, LoginRequest& b) { a.Swap(&b); }
  inline void Swap(LoginRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<LoginRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LoginRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LoginRequest& from) { LoginRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LoginRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "space_service.LoginRequest"; }

 protected:
  explicit LoginRequest(::google::protobuf::Arena* arena);
  LoginRequest(::google::protobuf::Arena* arena, const LoginRequest& from);
  LoginRequest(::google::protobuf::Arena* arena, LoginRequest&& from) noexcept
      : LoginRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUsernameFieldNumber = 1,
  };
  // string username = 1;
  void clear_username() ;
  const std::string& username() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_username(Arg_&& arg, Args_... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* value);

  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(
      const std::string& value);
  std::string* _internal_mutable_username();

  public:
  // @@protoc_insertion_point(class_scope:space_service.LoginRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      43, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_LoginRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const LoginRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr username_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_space_5fservice_2eproto;
};
// -------------------------------------------------------------------

class LoginReply final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:space_service.LoginReply) */ {
 public:
  inline LoginReply() : LoginReply(nullptr) {}
  ~LoginReply() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LoginReply(
      ::google::protobuf::internal::ConstantInitialized);

  inline LoginReply(const LoginReply& from) : LoginReply(nullptr, from) {}
  inline LoginReply(LoginReply&& from) noexcept
      : LoginReply(nullptr, std::move(from)) {}
  inline LoginReply& operator=(const LoginReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginReply& operator=(LoginReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginReply* internal_default_instance() {
    return reinterpret_cast<const LoginReply*>(
        &_LoginReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(LoginReply& a, LoginReply& b) { a.Swap(&b); }
  inline void Swap(LoginReply* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<LoginReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LoginReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LoginReply& from) { LoginReply::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LoginReply* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "space_service.LoginReply"; }

 protected:
  explicit LoginReply(::google::protobuf::Arena* arena);
  LoginReply(::google::protobuf::Arena* arena, const LoginReply& from);
  LoginReply(::google::protobuf::Arena* arena, LoginReply&& from) noexcept
      : LoginReply(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kResultFieldNumber = 1,
    kEidFieldNumber = 2,
  };
  // int32 result = 1;
  void clear_result() ;
  ::int32_t result() const;
  void set_result(::int32_t value);

  private:
  ::int32_t _internal_result() const;
  void _internal_set_result(::int32_t value);

  public:
  // int32 eid = 2;
  void clear_eid() ;
  ::int32_t eid() const;
  void set_eid(::int32_t value);

  private:
  ::int32_t _internal_eid() const;
  void _internal_set_eid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:space_service.LoginReply)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_LoginReply_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const LoginReply& from_msg);
    ::int32_t result_;
    ::int32_t eid_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_space_5fservice_2eproto;
};
// -------------------------------------------------------------------

class AttrSet final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:space_service.AttrSet) */ {
 public:
  inline AttrSet() : AttrSet(nullptr) {}
  ~AttrSet() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AttrSet(
      ::google::protobuf::internal::ConstantInitialized);

  inline AttrSet(const AttrSet& from) : AttrSet(nullptr, from) {}
  inline AttrSet(AttrSet&& from) noexcept
      : AttrSet(nullptr, std::move(from)) {}
  inline AttrSet& operator=(const AttrSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline AttrSet& operator=(AttrSet&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AttrSet& default_instance() {
    return *internal_default_instance();
  }
  static inline const AttrSet* internal_default_instance() {
    return reinterpret_cast<const AttrSet*>(
        &_AttrSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(AttrSet& a, AttrSet& b) { a.Swap(&b); }
  inline void Swap(AttrSet* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AttrSet* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AttrSet* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AttrSet>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AttrSet& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AttrSet& from) { AttrSet::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AttrSet* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "space_service.AttrSet"; }

 protected:
  explicit AttrSet(::google::protobuf::Arena* arena);
  AttrSet(::google::protobuf::Arena* arena, const AttrSet& from);
  AttrSet(::google::protobuf::Arena* arena, AttrSet&& from) noexcept
      : AttrSet(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMaxHpFieldNumber = 1,
    kHpFieldNumber = 2,
    kMaxManaFieldNumber = 3,
    kManaFieldNumber = 4,
    kStatusFieldNumber = 5,
  };
  // int32 max_hp = 1;
  void clear_max_hp() ;
  ::int32_t max_hp() const;
  void set_max_hp(::int32_t value);

  private:
  ::int32_t _internal_max_hp() const;
  void _internal_set_max_hp(::int32_t value);

  public:
  // int32 hp = 2;
  void clear_hp() ;
  ::int32_t hp() const;
  void set_hp(::int32_t value);

  private:
  ::int32_t _internal_hp() const;
  void _internal_set_hp(::int32_t value);

  public:
  // int32 max_mana = 3;
  void clear_max_mana() ;
  ::int32_t max_mana() const;
  void set_max_mana(::int32_t value);

  private:
  ::int32_t _internal_max_mana() const;
  void _internal_set_max_mana(::int32_t value);

  public:
  // int32 mana = 4;
  void clear_mana() ;
  ::int32_t mana() const;
  void set_mana(::int32_t value);

  private:
  ::int32_t _internal_mana() const;
  void _internal_set_mana(::int32_t value);

  public:
  // int32 status = 5;
  void clear_status() ;
  ::int32_t status() const;
  void set_status(::int32_t value);

  private:
  ::int32_t _internal_status() const;
  void _internal_set_status(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:space_service.AttrSet)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_AttrSet_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AttrSet& from_msg);
    ::int32_t max_hp_;
    ::int32_t hp_;
    ::int32_t max_mana_;
    ::int32_t mana_;
    ::int32_t status_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_space_5fservice_2eproto;
};
// -------------------------------------------------------------------

class Animation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:space_service.Animation) */ {
 public:
  inline Animation() : Animation(nullptr) {}
  ~Animation() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Animation(
      ::google::protobuf::internal::ConstantInitialized);

  inline Animation(const Animation& from) : Animation(nullptr, from) {}
  inline Animation(Animation&& from) noexcept
      : Animation(nullptr, std::move(from)) {}
  inline Animation& operator=(const Animation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Animation& operator=(Animation&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Animation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Animation* internal_default_instance() {
    return reinterpret_cast<const Animation*>(
        &_Animation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(Animation& a, Animation& b) { a.Swap(&b); }
  inline void Swap(Animation* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Animation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Animation* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Animation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Animation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Animation& from) { Animation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Animation* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "space_service.Animation"; }

 protected:
  explicit Animation(::google::protobuf::Arena* arena);
  Animation(::google::protobuf::Arena* arena, const Animation& from);
  Animation(::google::protobuf::Arena* arena, Animation&& from) noexcept
      : Animation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using OperationType = Animation_OperationType;
  static constexpr OperationType START = Animation_OperationType_START;
  static constexpr OperationType STOP = Animation_OperationType_STOP;
  static constexpr OperationType UPDATE = Animation_OperationType_UPDATE;
  static inline bool OperationType_IsValid(int value) {
    return Animation_OperationType_IsValid(value);
  }
  static constexpr OperationType OperationType_MIN = Animation_OperationType_OperationType_MIN;
  static constexpr OperationType OperationType_MAX = Animation_OperationType_OperationType_MAX;
  static constexpr int OperationType_ARRAYSIZE = Animation_OperationType_OperationType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* OperationType_descriptor() {
    return Animation_OperationType_descriptor();
  }
  template <typename T>
  static inline const std::string& OperationType_Name(T value) {
    return Animation_OperationType_Name(value);
  }
  static inline bool OperationType_Parse(absl::string_view name, OperationType* value) {
    return Animation_OperationType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
    kOpFieldNumber = 2,
    kSpeedFieldNumber = 3,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .space_service.Animation.OperationType op = 2;
  void clear_op() ;
  ::space_service::Animation_OperationType op() const;
  void set_op(::space_service::Animation_OperationType value);

  private:
  ::space_service::Animation_OperationType _internal_op() const;
  void _internal_set_op(::space_service::Animation_OperationType value);

  public:
  // float speed = 3;
  void clear_speed() ;
  float speed() const;
  void set_speed(float value);

  private:
  float _internal_speed() const;
  void _internal_set_speed(float value);

  public:
  // @@protoc_insertion_point(class_scope:space_service.Animation)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      36, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Animation_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Animation& from_msg);
    ::google::protobuf::internal::ArenaStringPtr name_;
    int op_;
    float speed_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_space_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PlayerAttrSet final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:space_service.PlayerAttrSet) */ {
 public:
  inline PlayerAttrSet() : PlayerAttrSet(nullptr) {}
  ~PlayerAttrSet() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerAttrSet(
      ::google::protobuf::internal::ConstantInitialized);

  inline PlayerAttrSet(const PlayerAttrSet& from) : PlayerAttrSet(nullptr, from) {}
  inline PlayerAttrSet(PlayerAttrSet&& from) noexcept
      : PlayerAttrSet(nullptr, std::move(from)) {}
  inline PlayerAttrSet& operator=(const PlayerAttrSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerAttrSet& operator=(PlayerAttrSet&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerAttrSet& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerAttrSet* internal_default_instance() {
    return reinterpret_cast<const PlayerAttrSet*>(
        &_PlayerAttrSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(PlayerAttrSet& a, PlayerAttrSet& b) { a.Swap(&b); }
  inline void Swap(PlayerAttrSet* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerAttrSet* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerAttrSet* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PlayerAttrSet>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerAttrSet& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerAttrSet& from) { PlayerAttrSet::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlayerAttrSet* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "space_service.PlayerAttrSet"; }

 protected:
  explicit PlayerAttrSet(::google::protobuf::Arena* arena);
  PlayerAttrSet(::google::protobuf::Arena* arena, const PlayerAttrSet& from);
  PlayerAttrSet(::google::protobuf::Arena* arena, PlayerAttrSet&& from) noexcept
      : PlayerAttrSet(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDataFieldNumber = 2,
    kEidFieldNumber = 1,
  };
  // .space_service.AttrSet data = 2;
  bool has_data() const;
  void clear_data() ;
  const ::space_service::AttrSet& data() const;
  PROTOBUF_NODISCARD ::space_service::AttrSet* release_data();
  ::space_service::AttrSet* mutable_data();
  void set_allocated_data(::space_service::AttrSet* value);
  void unsafe_arena_set_allocated_data(::space_service::AttrSet* value);
  ::space_service::AttrSet* unsafe_arena_release_data();

  private:
  const ::space_service::AttrSet& _internal_data() const;
  ::space_service::AttrSet* _internal_mutable_data();

  public:
  // int32 eid = 1;
  void clear_eid() ;
  ::int32_t eid() const;
  void set_eid(::int32_t value);

  private:
  ::int32_t _internal_eid() const;
  void _internal_set_eid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:space_service.PlayerAttrSet)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_PlayerAttrSet_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PlayerAttrSet& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::space_service::AttrSet* data_;
    ::int32_t eid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_space_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PlayerAnimation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:space_service.PlayerAnimation) */ {
 public:
  inline PlayerAnimation() : PlayerAnimation(nullptr) {}
  ~PlayerAnimation() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerAnimation(
      ::google::protobuf::internal::ConstantInitialized);

  inline PlayerAnimation(const PlayerAnimation& from) : PlayerAnimation(nullptr, from) {}
  inline PlayerAnimation(PlayerAnimation&& from) noexcept
      : PlayerAnimation(nullptr, std::move(from)) {}
  inline PlayerAnimation& operator=(const PlayerAnimation& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerAnimation& operator=(PlayerAnimation&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerAnimation& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerAnimation* internal_default_instance() {
    return reinterpret_cast<const PlayerAnimation*>(
        &_PlayerAnimation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(PlayerAnimation& a, PlayerAnimation& b) { a.Swap(&b); }
  inline void Swap(PlayerAnimation* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerAnimation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerAnimation* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PlayerAnimation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerAnimation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerAnimation& from) { PlayerAnimation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlayerAnimation* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "space_service.PlayerAnimation"; }

 protected:
  explicit PlayerAnimation(::google::protobuf::Arena* arena);
  PlayerAnimation(::google::protobuf::Arena* arena, const PlayerAnimation& from);
  PlayerAnimation(::google::protobuf::Arena* arena, PlayerAnimation&& from) noexcept
      : PlayerAnimation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDataFieldNumber = 2,
    kEidFieldNumber = 1,
  };
  // .space_service.Animation data = 2;
  bool has_data() const;
  void clear_data() ;
  const ::space_service::Animation& data() const;
  PROTOBUF_NODISCARD ::space_service::Animation* release_data();
  ::space_service::Animation* mutable_data();
  void set_allocated_data(::space_service::Animation* value);
  void unsafe_arena_set_allocated_data(::space_service::Animation* value);
  ::space_service::Animation* unsafe_arena_release_data();

  private:
  const ::space_service::Animation& _internal_data() const;
  ::space_service::Animation* _internal_mutable_data();

  public:
  // int32 eid = 1;
  void clear_eid() ;
  ::int32_t eid() const;
  void set_eid(::int32_t value);

  private:
  ::int32_t _internal_eid() const;
  void _internal_set_eid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:space_service.PlayerAnimation)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_PlayerAnimation_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PlayerAnimation& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::space_service::Animation* data_;
    ::int32_t eid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_space_5fservice_2eproto;
};
// -------------------------------------------------------------------

class Movement final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:space_service.Movement) */ {
 public:
  inline Movement() : Movement(nullptr) {}
  ~Movement() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Movement(
      ::google::protobuf::internal::ConstantInitialized);

  inline Movement(const Movement& from) : Movement(nullptr, from) {}
  inline Movement(Movement&& from) noexcept
      : Movement(nullptr, std::move(from)) {}
  inline Movement& operator=(const Movement& from) {
    CopyFrom(from);
    return *this;
  }
  inline Movement& operator=(Movement&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Movement& default_instance() {
    return *internal_default_instance();
  }
  static inline const Movement* internal_default_instance() {
    return reinterpret_cast<const Movement*>(
        &_Movement_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(Movement& a, Movement& b) { a.Swap(&b); }
  inline void Swap(Movement* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Movement* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Movement* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Movement>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Movement& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Movement& from) { Movement::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Movement* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "space_service.Movement"; }

 protected:
  explicit Movement(::google::protobuf::Arena* arena);
  Movement(::google::protobuf::Arena* arena, const Movement& from);
  Movement(::google::protobuf::Arena* arena, Movement&& from) noexcept
      : Movement(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPositionFieldNumber = 1,
    kRotationFieldNumber = 2,
    kVelocityFieldNumber = 3,
    kAccelerationFieldNumber = 4,
    kAngularVelocityFieldNumber = 5,
    kModeFieldNumber = 6,
    kTimestampFieldNumber = 7,
  };
  // .space_service.Vector3f position = 1;
  bool has_position() const;
  void clear_position() ;
  const ::space_service::Vector3f& position() const;
  PROTOBUF_NODISCARD ::space_service::Vector3f* release_position();
  ::space_service::Vector3f* mutable_position();
  void set_allocated_position(::space_service::Vector3f* value);
  void unsafe_arena_set_allocated_position(::space_service::Vector3f* value);
  ::space_service::Vector3f* unsafe_arena_release_position();

  private:
  const ::space_service::Vector3f& _internal_position() const;
  ::space_service::Vector3f* _internal_mutable_position();

  public:
  // .space_service.Vector3f rotation = 2;
  bool has_rotation() const;
  void clear_rotation() ;
  const ::space_service::Vector3f& rotation() const;
  PROTOBUF_NODISCARD ::space_service::Vector3f* release_rotation();
  ::space_service::Vector3f* mutable_rotation();
  void set_allocated_rotation(::space_service::Vector3f* value);
  void unsafe_arena_set_allocated_rotation(::space_service::Vector3f* value);
  ::space_service::Vector3f* unsafe_arena_release_rotation();

  private:
  const ::space_service::Vector3f& _internal_rotation() const;
  ::space_service::Vector3f* _internal_mutable_rotation();

  public:
  // optional .space_service.Vector3f velocity = 3;
  bool has_velocity() const;
  void clear_velocity() ;
  const ::space_service::Vector3f& velocity() const;
  PROTOBUF_NODISCARD ::space_service::Vector3f* release_velocity();
  ::space_service::Vector3f* mutable_velocity();
  void set_allocated_velocity(::space_service::Vector3f* value);
  void unsafe_arena_set_allocated_velocity(::space_service::Vector3f* value);
  ::space_service::Vector3f* unsafe_arena_release_velocity();

  private:
  const ::space_service::Vector3f& _internal_velocity() const;
  ::space_service::Vector3f* _internal_mutable_velocity();

  public:
  // optional .space_service.Vector3f acceleration = 4;
  bool has_acceleration() const;
  void clear_acceleration() ;
  const ::space_service::Vector3f& acceleration() const;
  PROTOBUF_NODISCARD ::space_service::Vector3f* release_acceleration();
  ::space_service::Vector3f* mutable_acceleration();
  void set_allocated_acceleration(::space_service::Vector3f* value);
  void unsafe_arena_set_allocated_acceleration(::space_service::Vector3f* value);
  ::space_service::Vector3f* unsafe_arena_release_acceleration();

  private:
  const ::space_service::Vector3f& _internal_acceleration() const;
  ::space_service::Vector3f* _internal_mutable_acceleration();

  public:
  // optional .space_service.Vector3f angular_velocity = 5;
  bool has_angular_velocity() const;
  void clear_angular_velocity() ;
  const ::space_service::Vector3f& angular_velocity() const;
  PROTOBUF_NODISCARD ::space_service::Vector3f* release_angular_velocity();
  ::space_service::Vector3f* mutable_angular_velocity();
  void set_allocated_angular_velocity(::space_service::Vector3f* value);
  void unsafe_arena_set_allocated_angular_velocity(::space_service::Vector3f* value);
  ::space_service::Vector3f* unsafe_arena_release_angular_velocity();

  private:
  const ::space_service::Vector3f& _internal_angular_velocity() const;
  ::space_service::Vector3f* _internal_mutable_angular_velocity();

  public:
  // int32 mode = 6;
  void clear_mode() ;
  ::int32_t mode() const;
  void set_mode(::int32_t value);

  private:
  ::int32_t _internal_mode() const;
  void _internal_set_mode(::int32_t value);

  public:
  // float timestamp = 7;
  void clear_timestamp() ;
  float timestamp() const;
  void set_timestamp(float value);

  private:
  float _internal_timestamp() const;
  void _internal_set_timestamp(float value);

  public:
  // @@protoc_insertion_point(class_scope:space_service.Movement)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 5,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Movement_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Movement& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::space_service::Vector3f* position_;
    ::space_service::Vector3f* rotation_;
    ::space_service::Vector3f* velocity_;
    ::space_service::Vector3f* acceleration_;
    ::space_service::Vector3f* angular_velocity_;
    ::int32_t mode_;
    float timestamp_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_space_5fservice_2eproto;
};
// -------------------------------------------------------------------

class JoinReply final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:space_service.JoinReply) */ {
 public:
  inline JoinReply() : JoinReply(nullptr) {}
  ~JoinReply() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR JoinReply(
      ::google::protobuf::internal::ConstantInitialized);

  inline JoinReply(const JoinReply& from) : JoinReply(nullptr, from) {}
  inline JoinReply(JoinReply&& from) noexcept
      : JoinReply(nullptr, std::move(from)) {}
  inline JoinReply& operator=(const JoinReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinReply& operator=(JoinReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JoinReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const JoinReply* internal_default_instance() {
    return reinterpret_cast<const JoinReply*>(
        &_JoinReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(JoinReply& a, JoinReply& b) { a.Swap(&b); }
  inline void Swap(JoinReply* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JoinReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<JoinReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const JoinReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const JoinReply& from) { JoinReply::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(JoinReply* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "space_service.JoinReply"; }

 protected:
  explicit JoinReply(::google::protobuf::Arena* arena);
  JoinReply(::google::protobuf::Arena* arena, const JoinReply& from);
  JoinReply(::google::protobuf::Arena* arena, JoinReply&& from) noexcept
      : JoinReply(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPositionFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // optional .space_service.Vector3f position = 2;
  bool has_position() const;
  void clear_position() ;
  const ::space_service::Vector3f& position() const;
  PROTOBUF_NODISCARD ::space_service::Vector3f* release_position();
  ::space_service::Vector3f* mutable_position();
  void set_allocated_position(::space_service::Vector3f* value);
  void unsafe_arena_set_allocated_position(::space_service::Vector3f* value);
  ::space_service::Vector3f* unsafe_arena_release_position();

  private:
  const ::space_service::Vector3f& _internal_position() const;
  ::space_service::Vector3f* _internal_mutable_position();

  public:
  // int32 result = 1;
  void clear_result() ;
  ::int32_t result() const;
  void set_result(::int32_t value);

  private:
  ::int32_t _internal_result() const;
  void _internal_set_result(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:space_service.JoinReply)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_JoinReply_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const JoinReply& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::space_service::Vector3f* position_;
    ::int32_t result_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_space_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PlayerMovement final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:space_service.PlayerMovement) */ {
 public:
  inline PlayerMovement() : PlayerMovement(nullptr) {}
  ~PlayerMovement() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerMovement(
      ::google::protobuf::internal::ConstantInitialized);

  inline PlayerMovement(const PlayerMovement& from) : PlayerMovement(nullptr, from) {}
  inline PlayerMovement(PlayerMovement&& from) noexcept
      : PlayerMovement(nullptr, std::move(from)) {}
  inline PlayerMovement& operator=(const PlayerMovement& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerMovement& operator=(PlayerMovement&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerMovement& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerMovement* internal_default_instance() {
    return reinterpret_cast<const PlayerMovement*>(
        &_PlayerMovement_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(PlayerMovement& a, PlayerMovement& b) { a.Swap(&b); }
  inline void Swap(PlayerMovement* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerMovement* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerMovement* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PlayerMovement>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerMovement& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerMovement& from) { PlayerMovement::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlayerMovement* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "space_service.PlayerMovement"; }

 protected:
  explicit PlayerMovement(::google::protobuf::Arena* arena);
  PlayerMovement(::google::protobuf::Arena* arena, const PlayerMovement& from);
  PlayerMovement(::google::protobuf::Arena* arena, PlayerMovement&& from) noexcept
      : PlayerMovement(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDataFieldNumber = 2,
    kEidFieldNumber = 1,
  };
  // .space_service.Movement data = 2;
  bool has_data() const;
  void clear_data() ;
  const ::space_service::Movement& data() const;
  PROTOBUF_NODISCARD ::space_service::Movement* release_data();
  ::space_service::Movement* mutable_data();
  void set_allocated_data(::space_service::Movement* value);
  void unsafe_arena_set_allocated_data(::space_service::Movement* value);
  ::space_service::Movement* unsafe_arena_release_data();

  private:
  const ::space_service::Movement& _internal_data() const;
  ::space_service::Movement* _internal_mutable_data();

  public:
  // int32 eid = 1;
  void clear_eid() ;
  ::int32_t eid() const;
  void set_eid(::int32_t value);

  private:
  ::int32_t _internal_eid() const;
  void _internal_set_eid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:space_service.PlayerMovement)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_PlayerMovement_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PlayerMovement& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::space_service::Movement* data_;
    ::int32_t eid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_space_5fservice_2eproto;
};
// -------------------------------------------------------------------

class AoiPlayer final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:space_service.AoiPlayer) */ {
 public:
  inline AoiPlayer() : AoiPlayer(nullptr) {}
  ~AoiPlayer() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AoiPlayer(
      ::google::protobuf::internal::ConstantInitialized);

  inline AoiPlayer(const AoiPlayer& from) : AoiPlayer(nullptr, from) {}
  inline AoiPlayer(AoiPlayer&& from) noexcept
      : AoiPlayer(nullptr, std::move(from)) {}
  inline AoiPlayer& operator=(const AoiPlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline AoiPlayer& operator=(AoiPlayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AoiPlayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const AoiPlayer* internal_default_instance() {
    return reinterpret_cast<const AoiPlayer*>(
        &_AoiPlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(AoiPlayer& a, AoiPlayer& b) { a.Swap(&b); }
  inline void Swap(AoiPlayer* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AoiPlayer* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AoiPlayer* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AoiPlayer>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AoiPlayer& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AoiPlayer& from) { AoiPlayer::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AoiPlayer* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "space_service.AoiPlayer"; }

 protected:
  explicit AoiPlayer(::google::protobuf::Arena* arena);
  AoiPlayer(::google::protobuf::Arena* arena, const AoiPlayer& from);
  AoiPlayer(::google::protobuf::Arena* arena, AoiPlayer&& from) noexcept
      : AoiPlayer(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 2,
    kPositionFieldNumber = 3,
    kTransformFieldNumber = 4,
    kAttrSetFieldNumber = 5,
    kEidFieldNumber = 1,
  };
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .space_service.Vector3f position = 3;
  bool has_position() const;
  void clear_position() ;
  const ::space_service::Vector3f& position() const;
  PROTOBUF_NODISCARD ::space_service::Vector3f* release_position();
  ::space_service::Vector3f* mutable_position();
  void set_allocated_position(::space_service::Vector3f* value);
  void unsafe_arena_set_allocated_position(::space_service::Vector3f* value);
  ::space_service::Vector3f* unsafe_arena_release_position();

  private:
  const ::space_service::Vector3f& _internal_position() const;
  ::space_service::Vector3f* _internal_mutable_position();

  public:
  // .space_service.Movement transform = 4;
  bool has_transform() const;
  void clear_transform() ;
  const ::space_service::Movement& transform() const;
  PROTOBUF_NODISCARD ::space_service::Movement* release_transform();
  ::space_service::Movement* mutable_transform();
  void set_allocated_transform(::space_service::Movement* value);
  void unsafe_arena_set_allocated_transform(::space_service::Movement* value);
  ::space_service::Movement* unsafe_arena_release_transform();

  private:
  const ::space_service::Movement& _internal_transform() const;
  ::space_service::Movement* _internal_mutable_transform();

  public:
  // .space_service.AttrSet attr_set = 5;
  bool has_attr_set() const;
  void clear_attr_set() ;
  const ::space_service::AttrSet& attr_set() const;
  PROTOBUF_NODISCARD ::space_service::AttrSet* release_attr_set();
  ::space_service::AttrSet* mutable_attr_set();
  void set_allocated_attr_set(::space_service::AttrSet* value);
  void unsafe_arena_set_allocated_attr_set(::space_service::AttrSet* value);
  ::space_service::AttrSet* unsafe_arena_release_attr_set();

  private:
  const ::space_service::AttrSet& _internal_attr_set() const;
  ::space_service::AttrSet* _internal_mutable_attr_set();

  public:
  // int32 eid = 1;
  void clear_eid() ;
  ::int32_t eid() const;
  void set_eid(::int32_t value);

  private:
  ::int32_t _internal_eid() const;
  void _internal_set_eid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:space_service.AoiPlayer)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 3,
      36, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_AoiPlayer_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AoiPlayer& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::space_service::Vector3f* position_;
    ::space_service::Movement* transform_;
    ::space_service::AttrSet* attr_set_;
    ::int32_t eid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_space_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PlayersEnterSight final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:space_service.PlayersEnterSight) */ {
 public:
  inline PlayersEnterSight() : PlayersEnterSight(nullptr) {}
  ~PlayersEnterSight() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayersEnterSight(
      ::google::protobuf::internal::ConstantInitialized);

  inline PlayersEnterSight(const PlayersEnterSight& from) : PlayersEnterSight(nullptr, from) {}
  inline PlayersEnterSight(PlayersEnterSight&& from) noexcept
      : PlayersEnterSight(nullptr, std::move(from)) {}
  inline PlayersEnterSight& operator=(const PlayersEnterSight& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayersEnterSight& operator=(PlayersEnterSight&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayersEnterSight& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayersEnterSight* internal_default_instance() {
    return reinterpret_cast<const PlayersEnterSight*>(
        &_PlayersEnterSight_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(PlayersEnterSight& a, PlayersEnterSight& b) { a.Swap(&b); }
  inline void Swap(PlayersEnterSight* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayersEnterSight* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayersEnterSight* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PlayersEnterSight>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayersEnterSight& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayersEnterSight& from) { PlayersEnterSight::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlayersEnterSight* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "space_service.PlayersEnterSight"; }

 protected:
  explicit PlayersEnterSight(::google::protobuf::Arena* arena);
  PlayersEnterSight(::google::protobuf::Arena* arena, const PlayersEnterSight& from);
  PlayersEnterSight(::google::protobuf::Arena* arena, PlayersEnterSight&& from) noexcept
      : PlayersEnterSight(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPlayersFieldNumber = 1,
  };
  // repeated .space_service.AoiPlayer players = 1;
  int players_size() const;
  private:
  int _internal_players_size() const;

  public:
  void clear_players() ;
  ::space_service::AoiPlayer* mutable_players(int index);
  ::google::protobuf::RepeatedPtrField<::space_service::AoiPlayer>* mutable_players();

  private:
  const ::google::protobuf::RepeatedPtrField<::space_service::AoiPlayer>& _internal_players() const;
  ::google::protobuf::RepeatedPtrField<::space_service::AoiPlayer>* _internal_mutable_players();
  public:
  const ::space_service::AoiPlayer& players(int index) const;
  ::space_service::AoiPlayer* add_players();
  const ::google::protobuf::RepeatedPtrField<::space_service::AoiPlayer>& players() const;
  // @@protoc_insertion_point(class_scope:space_service.PlayersEnterSight)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_PlayersEnterSight_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PlayersEnterSight& from_msg);
    ::google::protobuf::RepeatedPtrField< ::space_service::AoiPlayer > players_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_space_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PlayerMovements final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:space_service.PlayerMovements) */ {
 public:
  inline PlayerMovements() : PlayerMovements(nullptr) {}
  ~PlayerMovements() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerMovements(
      ::google::protobuf::internal::ConstantInitialized);

  inline PlayerMovements(const PlayerMovements& from) : PlayerMovements(nullptr, from) {}
  inline PlayerMovements(PlayerMovements&& from) noexcept
      : PlayerMovements(nullptr, std::move(from)) {}
  inline PlayerMovements& operator=(const PlayerMovements& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerMovements& operator=(PlayerMovements&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerMovements& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerMovements* internal_default_instance() {
    return reinterpret_cast<const PlayerMovements*>(
        &_PlayerMovements_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(PlayerMovements& a, PlayerMovements& b) { a.Swap(&b); }
  inline void Swap(PlayerMovements* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerMovements* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerMovements* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PlayerMovements>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerMovements& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerMovements& from) { PlayerMovements::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlayerMovements* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "space_service.PlayerMovements"; }

 protected:
  explicit PlayerMovements(::google::protobuf::Arena* arena);
  PlayerMovements(::google::protobuf::Arena* arena, const PlayerMovements& from);
  PlayerMovements(::google::protobuf::Arena* arena, PlayerMovements&& from) noexcept
      : PlayerMovements(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDatasFieldNumber = 1,
  };
  // repeated .space_service.PlayerMovement datas = 1;
  int datas_size() const;
  private:
  int _internal_datas_size() const;

  public:
  void clear_datas() ;
  ::space_service::PlayerMovement* mutable_datas(int index);
  ::google::protobuf::RepeatedPtrField<::space_service::PlayerMovement>* mutable_datas();

  private:
  const ::google::protobuf::RepeatedPtrField<::space_service::PlayerMovement>& _internal_datas() const;
  ::google::protobuf::RepeatedPtrField<::space_service::PlayerMovement>* _internal_mutable_datas();
  public:
  const ::space_service::PlayerMovement& datas(int index) const;
  ::space_service::PlayerMovement* add_datas();
  const ::google::protobuf::RepeatedPtrField<::space_service::PlayerMovement>& datas() const;
  // @@protoc_insertion_point(class_scope:space_service.PlayerMovements)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_PlayerMovements_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PlayerMovements& from_msg);
    ::google::protobuf::RepeatedPtrField< ::space_service::PlayerMovement > datas_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_space_5fservice_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Vector3f

// float x = 1;
inline void Vector3f::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = 0;
}
inline float Vector3f::x() const {
  // @@protoc_insertion_point(field_get:space_service.Vector3f.x)
  return _internal_x();
}
inline void Vector3f::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:space_service.Vector3f.x)
}
inline float Vector3f::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.x_;
}
inline void Vector3f::_internal_set_x(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = value;
}

// float y = 2;
inline void Vector3f::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = 0;
}
inline float Vector3f::y() const {
  // @@protoc_insertion_point(field_get:space_service.Vector3f.y)
  return _internal_y();
}
inline void Vector3f::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:space_service.Vector3f.y)
}
inline float Vector3f::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.y_;
}
inline void Vector3f::_internal_set_y(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = value;
}

// float z = 3;
inline void Vector3f::clear_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = 0;
}
inline float Vector3f::z() const {
  // @@protoc_insertion_point(field_get:space_service.Vector3f.z)
  return _internal_z();
}
inline void Vector3f::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:space_service.Vector3f.z)
}
inline float Vector3f::_internal_z() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.z_;
}
inline void Vector3f::_internal_set_z(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// Movement

// .space_service.Vector3f position = 1;
inline bool Movement::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void Movement::clear_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::space_service::Vector3f& Movement::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::space_service::Vector3f* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::space_service::Vector3f&>(::space_service::_Vector3f_default_instance_);
}
inline const ::space_service::Vector3f& Movement::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:space_service.Movement.position)
  return _internal_position();
}
inline void Movement::unsafe_arena_set_allocated_position(::space_service::Vector3f* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::space_service::Vector3f*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:space_service.Movement.position)
}
inline ::space_service::Vector3f* Movement::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::space_service::Vector3f* released = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::space_service::Vector3f* Movement::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:space_service.Movement.position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::space_service::Vector3f* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::space_service::Vector3f* Movement::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::space_service::Vector3f>(GetArena());
    _impl_.position_ = reinterpret_cast<::space_service::Vector3f*>(p);
  }
  return _impl_.position_;
}
inline ::space_service::Vector3f* Movement::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::space_service::Vector3f* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:space_service.Movement.position)
  return _msg;
}
inline void Movement::set_allocated_position(::space_service::Vector3f* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_ = reinterpret_cast<::space_service::Vector3f*>(value);
  // @@protoc_insertion_point(field_set_allocated:space_service.Movement.position)
}

// .space_service.Vector3f rotation = 2;
inline bool Movement::has_rotation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rotation_ != nullptr);
  return value;
}
inline void Movement::clear_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rotation_ != nullptr) _impl_.rotation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::space_service::Vector3f& Movement::_internal_rotation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::space_service::Vector3f* p = _impl_.rotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::space_service::Vector3f&>(::space_service::_Vector3f_default_instance_);
}
inline const ::space_service::Vector3f& Movement::rotation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:space_service.Movement.rotation)
  return _internal_rotation();
}
inline void Movement::unsafe_arena_set_allocated_rotation(::space_service::Vector3f* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rotation_);
  }
  _impl_.rotation_ = reinterpret_cast<::space_service::Vector3f*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:space_service.Movement.rotation)
}
inline ::space_service::Vector3f* Movement::release_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::space_service::Vector3f* released = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::space_service::Vector3f* Movement::unsafe_arena_release_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:space_service.Movement.rotation)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::space_service::Vector3f* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
  return temp;
}
inline ::space_service::Vector3f* Movement::_internal_mutable_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rotation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::space_service::Vector3f>(GetArena());
    _impl_.rotation_ = reinterpret_cast<::space_service::Vector3f*>(p);
  }
  return _impl_.rotation_;
}
inline ::space_service::Vector3f* Movement::mutable_rotation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::space_service::Vector3f* _msg = _internal_mutable_rotation();
  // @@protoc_insertion_point(field_mutable:space_service.Movement.rotation)
  return _msg;
}
inline void Movement::set_allocated_rotation(::space_service::Vector3f* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.rotation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.rotation_ = reinterpret_cast<::space_service::Vector3f*>(value);
  // @@protoc_insertion_point(field_set_allocated:space_service.Movement.rotation)
}

// optional .space_service.Vector3f velocity = 3;
inline bool Movement::has_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.velocity_ != nullptr);
  return value;
}
inline void Movement::clear_velocity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.velocity_ != nullptr) _impl_.velocity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::space_service::Vector3f& Movement::_internal_velocity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::space_service::Vector3f* p = _impl_.velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::space_service::Vector3f&>(::space_service::_Vector3f_default_instance_);
}
inline const ::space_service::Vector3f& Movement::velocity() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:space_service.Movement.velocity)
  return _internal_velocity();
}
inline void Movement::unsafe_arena_set_allocated_velocity(::space_service::Vector3f* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.velocity_);
  }
  _impl_.velocity_ = reinterpret_cast<::space_service::Vector3f*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:space_service.Movement.velocity)
}
inline ::space_service::Vector3f* Movement::release_velocity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::space_service::Vector3f* released = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::space_service::Vector3f* Movement::unsafe_arena_release_velocity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:space_service.Movement.velocity)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::space_service::Vector3f* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
  return temp;
}
inline ::space_service::Vector3f* Movement::_internal_mutable_velocity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.velocity_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::space_service::Vector3f>(GetArena());
    _impl_.velocity_ = reinterpret_cast<::space_service::Vector3f*>(p);
  }
  return _impl_.velocity_;
}
inline ::space_service::Vector3f* Movement::mutable_velocity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::space_service::Vector3f* _msg = _internal_mutable_velocity();
  // @@protoc_insertion_point(field_mutable:space_service.Movement.velocity)
  return _msg;
}
inline void Movement::set_allocated_velocity(::space_service::Vector3f* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.velocity_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.velocity_ = reinterpret_cast<::space_service::Vector3f*>(value);
  // @@protoc_insertion_point(field_set_allocated:space_service.Movement.velocity)
}

// optional .space_service.Vector3f acceleration = 4;
inline bool Movement::has_acceleration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.acceleration_ != nullptr);
  return value;
}
inline void Movement::clear_acceleration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.acceleration_ != nullptr) _impl_.acceleration_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::space_service::Vector3f& Movement::_internal_acceleration() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::space_service::Vector3f* p = _impl_.acceleration_;
  return p != nullptr ? *p : reinterpret_cast<const ::space_service::Vector3f&>(::space_service::_Vector3f_default_instance_);
}
inline const ::space_service::Vector3f& Movement::acceleration() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:space_service.Movement.acceleration)
  return _internal_acceleration();
}
inline void Movement::unsafe_arena_set_allocated_acceleration(::space_service::Vector3f* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.acceleration_);
  }
  _impl_.acceleration_ = reinterpret_cast<::space_service::Vector3f*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:space_service.Movement.acceleration)
}
inline ::space_service::Vector3f* Movement::release_acceleration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::space_service::Vector3f* released = _impl_.acceleration_;
  _impl_.acceleration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::space_service::Vector3f* Movement::unsafe_arena_release_acceleration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:space_service.Movement.acceleration)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::space_service::Vector3f* temp = _impl_.acceleration_;
  _impl_.acceleration_ = nullptr;
  return temp;
}
inline ::space_service::Vector3f* Movement::_internal_mutable_acceleration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.acceleration_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::space_service::Vector3f>(GetArena());
    _impl_.acceleration_ = reinterpret_cast<::space_service::Vector3f*>(p);
  }
  return _impl_.acceleration_;
}
inline ::space_service::Vector3f* Movement::mutable_acceleration() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::space_service::Vector3f* _msg = _internal_mutable_acceleration();
  // @@protoc_insertion_point(field_mutable:space_service.Movement.acceleration)
  return _msg;
}
inline void Movement::set_allocated_acceleration(::space_service::Vector3f* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.acceleration_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.acceleration_ = reinterpret_cast<::space_service::Vector3f*>(value);
  // @@protoc_insertion_point(field_set_allocated:space_service.Movement.acceleration)
}

// optional .space_service.Vector3f angular_velocity = 5;
inline bool Movement::has_angular_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.angular_velocity_ != nullptr);
  return value;
}
inline void Movement::clear_angular_velocity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.angular_velocity_ != nullptr) _impl_.angular_velocity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::space_service::Vector3f& Movement::_internal_angular_velocity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::space_service::Vector3f* p = _impl_.angular_velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::space_service::Vector3f&>(::space_service::_Vector3f_default_instance_);
}
inline const ::space_service::Vector3f& Movement::angular_velocity() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:space_service.Movement.angular_velocity)
  return _internal_angular_velocity();
}
inline void Movement::unsafe_arena_set_allocated_angular_velocity(::space_service::Vector3f* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.angular_velocity_);
  }
  _impl_.angular_velocity_ = reinterpret_cast<::space_service::Vector3f*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:space_service.Movement.angular_velocity)
}
inline ::space_service::Vector3f* Movement::release_angular_velocity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::space_service::Vector3f* released = _impl_.angular_velocity_;
  _impl_.angular_velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::space_service::Vector3f* Movement::unsafe_arena_release_angular_velocity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:space_service.Movement.angular_velocity)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::space_service::Vector3f* temp = _impl_.angular_velocity_;
  _impl_.angular_velocity_ = nullptr;
  return temp;
}
inline ::space_service::Vector3f* Movement::_internal_mutable_angular_velocity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.angular_velocity_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::space_service::Vector3f>(GetArena());
    _impl_.angular_velocity_ = reinterpret_cast<::space_service::Vector3f*>(p);
  }
  return _impl_.angular_velocity_;
}
inline ::space_service::Vector3f* Movement::mutable_angular_velocity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::space_service::Vector3f* _msg = _internal_mutable_angular_velocity();
  // @@protoc_insertion_point(field_mutable:space_service.Movement.angular_velocity)
  return _msg;
}
inline void Movement::set_allocated_angular_velocity(::space_service::Vector3f* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.angular_velocity_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.angular_velocity_ = reinterpret_cast<::space_service::Vector3f*>(value);
  // @@protoc_insertion_point(field_set_allocated:space_service.Movement.angular_velocity)
}

// int32 mode = 6;
inline void Movement::clear_mode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mode_ = 0;
}
inline ::int32_t Movement::mode() const {
  // @@protoc_insertion_point(field_get:space_service.Movement.mode)
  return _internal_mode();
}
inline void Movement::set_mode(::int32_t value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:space_service.Movement.mode)
}
inline ::int32_t Movement::_internal_mode() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.mode_;
}
inline void Movement::_internal_set_mode(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mode_ = value;
}

// float timestamp = 7;
inline void Movement::clear_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = 0;
}
inline float Movement::timestamp() const {
  // @@protoc_insertion_point(field_get:space_service.Movement.timestamp)
  return _internal_timestamp();
}
inline void Movement::set_timestamp(float value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:space_service.Movement.timestamp)
}
inline float Movement::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timestamp_;
}
inline void Movement::_internal_set_timestamp(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = value;
}

// -------------------------------------------------------------------

// LoginRequest

// string username = 1;
inline void LoginRequest::clear_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.ClearToEmpty();
}
inline const std::string& LoginRequest::username() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:space_service.LoginRequest.username)
  return _internal_username();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LoginRequest::set_username(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:space_service.LoginRequest.username)
}
inline std::string* LoginRequest::mutable_username() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:space_service.LoginRequest.username)
  return _s;
}
inline const std::string& LoginRequest::_internal_username() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.username_.Get();
}
inline void LoginRequest::_internal_set_username(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.Set(value, GetArena());
}
inline std::string* LoginRequest::_internal_mutable_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.username_.Mutable( GetArena());
}
inline std::string* LoginRequest::release_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:space_service.LoginRequest.username)
  return _impl_.username_.Release();
}
inline void LoginRequest::set_allocated_username(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.username_.IsDefault()) {
          _impl_.username_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:space_service.LoginRequest.username)
}

// -------------------------------------------------------------------

// LoginReply

// int32 result = 1;
inline void LoginReply::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = 0;
}
inline ::int32_t LoginReply::result() const {
  // @@protoc_insertion_point(field_get:space_service.LoginReply.result)
  return _internal_result();
}
inline void LoginReply::set_result(::int32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:space_service.LoginReply.result)
}
inline ::int32_t LoginReply::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.result_;
}
inline void LoginReply::_internal_set_result(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = value;
}

// int32 eid = 2;
inline void LoginReply::clear_eid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.eid_ = 0;
}
inline ::int32_t LoginReply::eid() const {
  // @@protoc_insertion_point(field_get:space_service.LoginReply.eid)
  return _internal_eid();
}
inline void LoginReply::set_eid(::int32_t value) {
  _internal_set_eid(value);
  // @@protoc_insertion_point(field_set:space_service.LoginReply.eid)
}
inline ::int32_t LoginReply::_internal_eid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.eid_;
}
inline void LoginReply::_internal_set_eid(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.eid_ = value;
}

// -------------------------------------------------------------------

// JoinReply

// int32 result = 1;
inline void JoinReply::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = 0;
}
inline ::int32_t JoinReply::result() const {
  // @@protoc_insertion_point(field_get:space_service.JoinReply.result)
  return _internal_result();
}
inline void JoinReply::set_result(::int32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:space_service.JoinReply.result)
}
inline ::int32_t JoinReply::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.result_;
}
inline void JoinReply::_internal_set_result(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = value;
}

// optional .space_service.Vector3f position = 2;
inline bool JoinReply::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void JoinReply::clear_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::space_service::Vector3f& JoinReply::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::space_service::Vector3f* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::space_service::Vector3f&>(::space_service::_Vector3f_default_instance_);
}
inline const ::space_service::Vector3f& JoinReply::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:space_service.JoinReply.position)
  return _internal_position();
}
inline void JoinReply::unsafe_arena_set_allocated_position(::space_service::Vector3f* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::space_service::Vector3f*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:space_service.JoinReply.position)
}
inline ::space_service::Vector3f* JoinReply::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::space_service::Vector3f* released = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::space_service::Vector3f* JoinReply::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:space_service.JoinReply.position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::space_service::Vector3f* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::space_service::Vector3f* JoinReply::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::space_service::Vector3f>(GetArena());
    _impl_.position_ = reinterpret_cast<::space_service::Vector3f*>(p);
  }
  return _impl_.position_;
}
inline ::space_service::Vector3f* JoinReply::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::space_service::Vector3f* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:space_service.JoinReply.position)
  return _msg;
}
inline void JoinReply::set_allocated_position(::space_service::Vector3f* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_ = reinterpret_cast<::space_service::Vector3f*>(value);
  // @@protoc_insertion_point(field_set_allocated:space_service.JoinReply.position)
}

// -------------------------------------------------------------------

// SkillInfo

// int32 skill_id = 1;
inline void SkillInfo::clear_skill_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.skill_id_ = 0;
}
inline ::int32_t SkillInfo::skill_id() const {
  // @@protoc_insertion_point(field_get:space_service.SkillInfo.skill_id)
  return _internal_skill_id();
}
inline void SkillInfo::set_skill_id(::int32_t value) {
  _internal_set_skill_id(value);
  // @@protoc_insertion_point(field_set:space_service.SkillInfo.skill_id)
}
inline ::int32_t SkillInfo::_internal_skill_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.skill_id_;
}
inline void SkillInfo::_internal_set_skill_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.skill_id_ = value;
}

// int32 next_cast_time = 2;
inline void SkillInfo::clear_next_cast_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_cast_time_ = 0;
}
inline ::int32_t SkillInfo::next_cast_time() const {
  // @@protoc_insertion_point(field_get:space_service.SkillInfo.next_cast_time)
  return _internal_next_cast_time();
}
inline void SkillInfo::set_next_cast_time(::int32_t value) {
  _internal_set_next_cast_time(value);
  // @@protoc_insertion_point(field_set:space_service.SkillInfo.next_cast_time)
}
inline ::int32_t SkillInfo::_internal_next_cast_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.next_cast_time_;
}
inline void SkillInfo::_internal_set_next_cast_time(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_cast_time_ = value;
}

// optional int32 cost_mana = 3;
inline bool SkillInfo::has_cost_mana() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SkillInfo::clear_cost_mana() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cost_mana_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t SkillInfo::cost_mana() const {
  // @@protoc_insertion_point(field_get:space_service.SkillInfo.cost_mana)
  return _internal_cost_mana();
}
inline void SkillInfo::set_cost_mana(::int32_t value) {
  _internal_set_cost_mana(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:space_service.SkillInfo.cost_mana)
}
inline ::int32_t SkillInfo::_internal_cost_mana() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cost_mana_;
}
inline void SkillInfo::_internal_set_cost_mana(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cost_mana_ = value;
}

// optional int32 cool_down = 4;
inline bool SkillInfo::has_cool_down() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SkillInfo::clear_cool_down() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cool_down_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t SkillInfo::cool_down() const {
  // @@protoc_insertion_point(field_get:space_service.SkillInfo.cool_down)
  return _internal_cool_down();
}
inline void SkillInfo::set_cool_down(::int32_t value) {
  _internal_set_cool_down(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:space_service.SkillInfo.cool_down)
}
inline ::int32_t SkillInfo::_internal_cool_down() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cool_down_;
}
inline void SkillInfo::_internal_set_cool_down(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cool_down_ = value;
}

// -------------------------------------------------------------------

// AttrSet

// int32 max_hp = 1;
inline void AttrSet::clear_max_hp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_hp_ = 0;
}
inline ::int32_t AttrSet::max_hp() const {
  // @@protoc_insertion_point(field_get:space_service.AttrSet.max_hp)
  return _internal_max_hp();
}
inline void AttrSet::set_max_hp(::int32_t value) {
  _internal_set_max_hp(value);
  // @@protoc_insertion_point(field_set:space_service.AttrSet.max_hp)
}
inline ::int32_t AttrSet::_internal_max_hp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_hp_;
}
inline void AttrSet::_internal_set_max_hp(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_hp_ = value;
}

// int32 hp = 2;
inline void AttrSet::clear_hp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hp_ = 0;
}
inline ::int32_t AttrSet::hp() const {
  // @@protoc_insertion_point(field_get:space_service.AttrSet.hp)
  return _internal_hp();
}
inline void AttrSet::set_hp(::int32_t value) {
  _internal_set_hp(value);
  // @@protoc_insertion_point(field_set:space_service.AttrSet.hp)
}
inline ::int32_t AttrSet::_internal_hp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hp_;
}
inline void AttrSet::_internal_set_hp(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hp_ = value;
}

// int32 max_mana = 3;
inline void AttrSet::clear_max_mana() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_mana_ = 0;
}
inline ::int32_t AttrSet::max_mana() const {
  // @@protoc_insertion_point(field_get:space_service.AttrSet.max_mana)
  return _internal_max_mana();
}
inline void AttrSet::set_max_mana(::int32_t value) {
  _internal_set_max_mana(value);
  // @@protoc_insertion_point(field_set:space_service.AttrSet.max_mana)
}
inline ::int32_t AttrSet::_internal_max_mana() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_mana_;
}
inline void AttrSet::_internal_set_max_mana(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_mana_ = value;
}

// int32 mana = 4;
inline void AttrSet::clear_mana() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mana_ = 0;
}
inline ::int32_t AttrSet::mana() const {
  // @@protoc_insertion_point(field_get:space_service.AttrSet.mana)
  return _internal_mana();
}
inline void AttrSet::set_mana(::int32_t value) {
  _internal_set_mana(value);
  // @@protoc_insertion_point(field_set:space_service.AttrSet.mana)
}
inline ::int32_t AttrSet::_internal_mana() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.mana_;
}
inline void AttrSet::_internal_set_mana(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mana_ = value;
}

// int32 status = 5;
inline void AttrSet::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = 0;
}
inline ::int32_t AttrSet::status() const {
  // @@protoc_insertion_point(field_get:space_service.AttrSet.status)
  return _internal_status();
}
inline void AttrSet::set_status(::int32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:space_service.AttrSet.status)
}
inline ::int32_t AttrSet::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.status_;
}
inline void AttrSet::_internal_set_status(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = value;
}

// -------------------------------------------------------------------

// AoiPlayer

// int32 eid = 1;
inline void AoiPlayer::clear_eid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.eid_ = 0;
}
inline ::int32_t AoiPlayer::eid() const {
  // @@protoc_insertion_point(field_get:space_service.AoiPlayer.eid)
  return _internal_eid();
}
inline void AoiPlayer::set_eid(::int32_t value) {
  _internal_set_eid(value);
  // @@protoc_insertion_point(field_set:space_service.AoiPlayer.eid)
}
inline ::int32_t AoiPlayer::_internal_eid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.eid_;
}
inline void AoiPlayer::_internal_set_eid(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.eid_ = value;
}

// string name = 2;
inline void AoiPlayer::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& AoiPlayer::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:space_service.AoiPlayer.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AoiPlayer::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:space_service.AoiPlayer.name)
}
inline std::string* AoiPlayer::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:space_service.AoiPlayer.name)
  return _s;
}
inline const std::string& AoiPlayer::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void AoiPlayer::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* AoiPlayer::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* AoiPlayer::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:space_service.AoiPlayer.name)
  return _impl_.name_.Release();
}
inline void AoiPlayer::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:space_service.AoiPlayer.name)
}

// .space_service.Vector3f position = 3;
inline bool AoiPlayer::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void AoiPlayer::clear_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::space_service::Vector3f& AoiPlayer::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::space_service::Vector3f* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::space_service::Vector3f&>(::space_service::_Vector3f_default_instance_);
}
inline const ::space_service::Vector3f& AoiPlayer::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:space_service.AoiPlayer.position)
  return _internal_position();
}
inline void AoiPlayer::unsafe_arena_set_allocated_position(::space_service::Vector3f* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::space_service::Vector3f*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:space_service.AoiPlayer.position)
}
inline ::space_service::Vector3f* AoiPlayer::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::space_service::Vector3f* released = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::space_service::Vector3f* AoiPlayer::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:space_service.AoiPlayer.position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::space_service::Vector3f* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::space_service::Vector3f* AoiPlayer::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::space_service::Vector3f>(GetArena());
    _impl_.position_ = reinterpret_cast<::space_service::Vector3f*>(p);
  }
  return _impl_.position_;
}
inline ::space_service::Vector3f* AoiPlayer::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::space_service::Vector3f* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:space_service.AoiPlayer.position)
  return _msg;
}
inline void AoiPlayer::set_allocated_position(::space_service::Vector3f* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_ = reinterpret_cast<::space_service::Vector3f*>(value);
  // @@protoc_insertion_point(field_set_allocated:space_service.AoiPlayer.position)
}

// .space_service.Movement transform = 4;
inline bool AoiPlayer::has_transform() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.transform_ != nullptr);
  return value;
}
inline void AoiPlayer::clear_transform() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.transform_ != nullptr) _impl_.transform_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::space_service::Movement& AoiPlayer::_internal_transform() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::space_service::Movement* p = _impl_.transform_;
  return p != nullptr ? *p : reinterpret_cast<const ::space_service::Movement&>(::space_service::_Movement_default_instance_);
}
inline const ::space_service::Movement& AoiPlayer::transform() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:space_service.AoiPlayer.transform)
  return _internal_transform();
}
inline void AoiPlayer::unsafe_arena_set_allocated_transform(::space_service::Movement* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.transform_);
  }
  _impl_.transform_ = reinterpret_cast<::space_service::Movement*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:space_service.AoiPlayer.transform)
}
inline ::space_service::Movement* AoiPlayer::release_transform() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::space_service::Movement* released = _impl_.transform_;
  _impl_.transform_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::space_service::Movement* AoiPlayer::unsafe_arena_release_transform() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:space_service.AoiPlayer.transform)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::space_service::Movement* temp = _impl_.transform_;
  _impl_.transform_ = nullptr;
  return temp;
}
inline ::space_service::Movement* AoiPlayer::_internal_mutable_transform() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.transform_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::space_service::Movement>(GetArena());
    _impl_.transform_ = reinterpret_cast<::space_service::Movement*>(p);
  }
  return _impl_.transform_;
}
inline ::space_service::Movement* AoiPlayer::mutable_transform() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::space_service::Movement* _msg = _internal_mutable_transform();
  // @@protoc_insertion_point(field_mutable:space_service.AoiPlayer.transform)
  return _msg;
}
inline void AoiPlayer::set_allocated_transform(::space_service::Movement* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.transform_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.transform_ = reinterpret_cast<::space_service::Movement*>(value);
  // @@protoc_insertion_point(field_set_allocated:space_service.AoiPlayer.transform)
}

// .space_service.AttrSet attr_set = 5;
inline bool AoiPlayer::has_attr_set() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.attr_set_ != nullptr);
  return value;
}
inline void AoiPlayer::clear_attr_set() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.attr_set_ != nullptr) _impl_.attr_set_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::space_service::AttrSet& AoiPlayer::_internal_attr_set() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::space_service::AttrSet* p = _impl_.attr_set_;
  return p != nullptr ? *p : reinterpret_cast<const ::space_service::AttrSet&>(::space_service::_AttrSet_default_instance_);
}
inline const ::space_service::AttrSet& AoiPlayer::attr_set() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:space_service.AoiPlayer.attr_set)
  return _internal_attr_set();
}
inline void AoiPlayer::unsafe_arena_set_allocated_attr_set(::space_service::AttrSet* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.attr_set_);
  }
  _impl_.attr_set_ = reinterpret_cast<::space_service::AttrSet*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:space_service.AoiPlayer.attr_set)
}
inline ::space_service::AttrSet* AoiPlayer::release_attr_set() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::space_service::AttrSet* released = _impl_.attr_set_;
  _impl_.attr_set_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::space_service::AttrSet* AoiPlayer::unsafe_arena_release_attr_set() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:space_service.AoiPlayer.attr_set)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::space_service::AttrSet* temp = _impl_.attr_set_;
  _impl_.attr_set_ = nullptr;
  return temp;
}
inline ::space_service::AttrSet* AoiPlayer::_internal_mutable_attr_set() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.attr_set_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::space_service::AttrSet>(GetArena());
    _impl_.attr_set_ = reinterpret_cast<::space_service::AttrSet*>(p);
  }
  return _impl_.attr_set_;
}
inline ::space_service::AttrSet* AoiPlayer::mutable_attr_set() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::space_service::AttrSet* _msg = _internal_mutable_attr_set();
  // @@protoc_insertion_point(field_mutable:space_service.AoiPlayer.attr_set)
  return _msg;
}
inline void AoiPlayer::set_allocated_attr_set(::space_service::AttrSet* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.attr_set_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.attr_set_ = reinterpret_cast<::space_service::AttrSet*>(value);
  // @@protoc_insertion_point(field_set_allocated:space_service.AoiPlayer.attr_set)
}

// -------------------------------------------------------------------

// PlayersEnterSight

// repeated .space_service.AoiPlayer players = 1;
inline int PlayersEnterSight::_internal_players_size() const {
  return _internal_players().size();
}
inline int PlayersEnterSight::players_size() const {
  return _internal_players_size();
}
inline void PlayersEnterSight::clear_players() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.players_.Clear();
}
inline ::space_service::AoiPlayer* PlayersEnterSight::mutable_players(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:space_service.PlayersEnterSight.players)
  return _internal_mutable_players()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::space_service::AoiPlayer>* PlayersEnterSight::mutable_players()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:space_service.PlayersEnterSight.players)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_players();
}
inline const ::space_service::AoiPlayer& PlayersEnterSight::players(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:space_service.PlayersEnterSight.players)
  return _internal_players().Get(index);
}
inline ::space_service::AoiPlayer* PlayersEnterSight::add_players() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::space_service::AoiPlayer* _add = _internal_mutable_players()->Add();
  // @@protoc_insertion_point(field_add:space_service.PlayersEnterSight.players)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::space_service::AoiPlayer>& PlayersEnterSight::players() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:space_service.PlayersEnterSight.players)
  return _internal_players();
}
inline const ::google::protobuf::RepeatedPtrField<::space_service::AoiPlayer>&
PlayersEnterSight::_internal_players() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.players_;
}
inline ::google::protobuf::RepeatedPtrField<::space_service::AoiPlayer>*
PlayersEnterSight::_internal_mutable_players() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.players_;
}

// -------------------------------------------------------------------

// PlayersLeaveSight

// repeated int32 players = 1;
inline int PlayersLeaveSight::_internal_players_size() const {
  return _internal_players().size();
}
inline int PlayersLeaveSight::players_size() const {
  return _internal_players_size();
}
inline void PlayersLeaveSight::clear_players() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.players_.Clear();
}
inline ::int32_t PlayersLeaveSight::players(int index) const {
  // @@protoc_insertion_point(field_get:space_service.PlayersLeaveSight.players)
  return _internal_players().Get(index);
}
inline void PlayersLeaveSight::set_players(int index, ::int32_t value) {
  _internal_mutable_players()->Set(index, value);
  // @@protoc_insertion_point(field_set:space_service.PlayersLeaveSight.players)
}
inline void PlayersLeaveSight::add_players(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_players()->Add(value);
  // @@protoc_insertion_point(field_add:space_service.PlayersLeaveSight.players)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& PlayersLeaveSight::players() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:space_service.PlayersLeaveSight.players)
  return _internal_players();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PlayersLeaveSight::mutable_players()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:space_service.PlayersLeaveSight.players)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_players();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
PlayersLeaveSight::_internal_players() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.players_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PlayersLeaveSight::_internal_mutable_players() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.players_;
}

// -------------------------------------------------------------------

// PlayerMovement

// int32 eid = 1;
inline void PlayerMovement::clear_eid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.eid_ = 0;
}
inline ::int32_t PlayerMovement::eid() const {
  // @@protoc_insertion_point(field_get:space_service.PlayerMovement.eid)
  return _internal_eid();
}
inline void PlayerMovement::set_eid(::int32_t value) {
  _internal_set_eid(value);
  // @@protoc_insertion_point(field_set:space_service.PlayerMovement.eid)
}
inline ::int32_t PlayerMovement::_internal_eid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.eid_;
}
inline void PlayerMovement::_internal_set_eid(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.eid_ = value;
}

// .space_service.Movement data = 2;
inline bool PlayerMovement::has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.data_ != nullptr);
  return value;
}
inline void PlayerMovement::clear_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.data_ != nullptr) _impl_.data_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::space_service::Movement& PlayerMovement::_internal_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::space_service::Movement* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::space_service::Movement&>(::space_service::_Movement_default_instance_);
}
inline const ::space_service::Movement& PlayerMovement::data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:space_service.PlayerMovement.data)
  return _internal_data();
}
inline void PlayerMovement::unsafe_arena_set_allocated_data(::space_service::Movement* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = reinterpret_cast<::space_service::Movement*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:space_service.PlayerMovement.data)
}
inline ::space_service::Movement* PlayerMovement::release_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::space_service::Movement* released = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::space_service::Movement* PlayerMovement::unsafe_arena_release_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:space_service.PlayerMovement.data)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::space_service::Movement* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::space_service::Movement* PlayerMovement::_internal_mutable_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.data_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::space_service::Movement>(GetArena());
    _impl_.data_ = reinterpret_cast<::space_service::Movement*>(p);
  }
  return _impl_.data_;
}
inline ::space_service::Movement* PlayerMovement::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::space_service::Movement* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:space_service.PlayerMovement.data)
  return _msg;
}
inline void PlayerMovement::set_allocated_data(::space_service::Movement* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.data_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.data_ = reinterpret_cast<::space_service::Movement*>(value);
  // @@protoc_insertion_point(field_set_allocated:space_service.PlayerMovement.data)
}

// -------------------------------------------------------------------

// PlayerMovements

// repeated .space_service.PlayerMovement datas = 1;
inline int PlayerMovements::_internal_datas_size() const {
  return _internal_datas().size();
}
inline int PlayerMovements::datas_size() const {
  return _internal_datas_size();
}
inline void PlayerMovements::clear_datas() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.datas_.Clear();
}
inline ::space_service::PlayerMovement* PlayerMovements::mutable_datas(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:space_service.PlayerMovements.datas)
  return _internal_mutable_datas()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::space_service::PlayerMovement>* PlayerMovements::mutable_datas()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:space_service.PlayerMovements.datas)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_datas();
}
inline const ::space_service::PlayerMovement& PlayerMovements::datas(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:space_service.PlayerMovements.datas)
  return _internal_datas().Get(index);
}
inline ::space_service::PlayerMovement* PlayerMovements::add_datas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::space_service::PlayerMovement* _add = _internal_mutable_datas()->Add();
  // @@protoc_insertion_point(field_add:space_service.PlayerMovements.datas)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::space_service::PlayerMovement>& PlayerMovements::datas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:space_service.PlayerMovements.datas)
  return _internal_datas();
}
inline const ::google::protobuf::RepeatedPtrField<::space_service::PlayerMovement>&
PlayerMovements::_internal_datas() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.datas_;
}
inline ::google::protobuf::RepeatedPtrField<::space_service::PlayerMovement>*
PlayerMovements::_internal_mutable_datas() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.datas_;
}

// -------------------------------------------------------------------

// Ping

// float t = 1;
inline void Ping::clear_t() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.t_ = 0;
}
inline float Ping::t() const {
  // @@protoc_insertion_point(field_get:space_service.Ping.t)
  return _internal_t();
}
inline void Ping::set_t(float value) {
  _internal_set_t(value);
  // @@protoc_insertion_point(field_set:space_service.Ping.t)
}
inline float Ping::_internal_t() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.t_;
}
inline void Ping::_internal_set_t(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.t_ = value;
}

// -------------------------------------------------------------------

// Pong

// float t = 1;
inline void Pong::clear_t() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.t_ = 0;
}
inline float Pong::t() const {
  // @@protoc_insertion_point(field_get:space_service.Pong.t)
  return _internal_t();
}
inline void Pong::set_t(float value) {
  _internal_set_t(value);
  // @@protoc_insertion_point(field_set:space_service.Pong.t)
}
inline float Pong::_internal_t() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.t_;
}
inline void Pong::_internal_set_t(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.t_ = value;
}

// int32 server_t = 2;
inline void Pong::clear_server_t() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_t_ = 0;
}
inline ::int32_t Pong::server_t() const {
  // @@protoc_insertion_point(field_get:space_service.Pong.server_t)
  return _internal_server_t();
}
inline void Pong::set_server_t(::int32_t value) {
  _internal_set_server_t(value);
  // @@protoc_insertion_point(field_set:space_service.Pong.server_t)
}
inline ::int32_t Pong::_internal_server_t() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.server_t_;
}
inline void Pong::_internal_set_server_t(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_t_ = value;
}

// -------------------------------------------------------------------

// NormalAttack

// int32 combo = 1;
inline void NormalAttack::clear_combo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.combo_ = 0;
}
inline ::int32_t NormalAttack::combo() const {
  // @@protoc_insertion_point(field_get:space_service.NormalAttack.combo)
  return _internal_combo();
}
inline void NormalAttack::set_combo(::int32_t value) {
  _internal_set_combo(value);
  // @@protoc_insertion_point(field_set:space_service.NormalAttack.combo)
}
inline ::int32_t NormalAttack::_internal_combo() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.combo_;
}
inline void NormalAttack::_internal_set_combo(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.combo_ = value;
}

// -------------------------------------------------------------------

// SkillAttack

// int32 skill_id = 1;
inline void SkillAttack::clear_skill_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.skill_id_ = 0;
}
inline ::int32_t SkillAttack::skill_id() const {
  // @@protoc_insertion_point(field_get:space_service.SkillAttack.skill_id)
  return _internal_skill_id();
}
inline void SkillAttack::set_skill_id(::int32_t value) {
  _internal_set_skill_id(value);
  // @@protoc_insertion_point(field_set:space_service.SkillAttack.skill_id)
}
inline ::int32_t SkillAttack::_internal_skill_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.skill_id_;
}
inline void SkillAttack::_internal_set_skill_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.skill_id_ = value;
}

// -------------------------------------------------------------------

// Animation

// string name = 1;
inline void Animation::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Animation::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:space_service.Animation.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Animation::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:space_service.Animation.name)
}
inline std::string* Animation::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:space_service.Animation.name)
  return _s;
}
inline const std::string& Animation::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void Animation::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Animation::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Animation::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:space_service.Animation.name)
  return _impl_.name_.Release();
}
inline void Animation::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:space_service.Animation.name)
}

// .space_service.Animation.OperationType op = 2;
inline void Animation::clear_op() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.op_ = 0;
}
inline ::space_service::Animation_OperationType Animation::op() const {
  // @@protoc_insertion_point(field_get:space_service.Animation.op)
  return _internal_op();
}
inline void Animation::set_op(::space_service::Animation_OperationType value) {
  _internal_set_op(value);
  // @@protoc_insertion_point(field_set:space_service.Animation.op)
}
inline ::space_service::Animation_OperationType Animation::_internal_op() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::space_service::Animation_OperationType>(_impl_.op_);
}
inline void Animation::_internal_set_op(::space_service::Animation_OperationType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.op_ = value;
}

// float speed = 3;
inline void Animation::clear_speed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.speed_ = 0;
}
inline float Animation::speed() const {
  // @@protoc_insertion_point(field_get:space_service.Animation.speed)
  return _internal_speed();
}
inline void Animation::set_speed(float value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:space_service.Animation.speed)
}
inline float Animation::_internal_speed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.speed_;
}
inline void Animation::_internal_set_speed(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.speed_ = value;
}

// -------------------------------------------------------------------

// PlayerAnimation

// int32 eid = 1;
inline void PlayerAnimation::clear_eid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.eid_ = 0;
}
inline ::int32_t PlayerAnimation::eid() const {
  // @@protoc_insertion_point(field_get:space_service.PlayerAnimation.eid)
  return _internal_eid();
}
inline void PlayerAnimation::set_eid(::int32_t value) {
  _internal_set_eid(value);
  // @@protoc_insertion_point(field_set:space_service.PlayerAnimation.eid)
}
inline ::int32_t PlayerAnimation::_internal_eid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.eid_;
}
inline void PlayerAnimation::_internal_set_eid(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.eid_ = value;
}

// .space_service.Animation data = 2;
inline bool PlayerAnimation::has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.data_ != nullptr);
  return value;
}
inline void PlayerAnimation::clear_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.data_ != nullptr) _impl_.data_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::space_service::Animation& PlayerAnimation::_internal_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::space_service::Animation* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::space_service::Animation&>(::space_service::_Animation_default_instance_);
}
inline const ::space_service::Animation& PlayerAnimation::data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:space_service.PlayerAnimation.data)
  return _internal_data();
}
inline void PlayerAnimation::unsafe_arena_set_allocated_data(::space_service::Animation* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = reinterpret_cast<::space_service::Animation*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:space_service.PlayerAnimation.data)
}
inline ::space_service::Animation* PlayerAnimation::release_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::space_service::Animation* released = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::space_service::Animation* PlayerAnimation::unsafe_arena_release_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:space_service.PlayerAnimation.data)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::space_service::Animation* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::space_service::Animation* PlayerAnimation::_internal_mutable_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.data_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::space_service::Animation>(GetArena());
    _impl_.data_ = reinterpret_cast<::space_service::Animation*>(p);
  }
  return _impl_.data_;
}
inline ::space_service::Animation* PlayerAnimation::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::space_service::Animation* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:space_service.PlayerAnimation.data)
  return _msg;
}
inline void PlayerAnimation::set_allocated_data(::space_service::Animation* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.data_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.data_ = reinterpret_cast<::space_service::Animation*>(value);
  // @@protoc_insertion_point(field_set_allocated:space_service.PlayerAnimation.data)
}

// -------------------------------------------------------------------

// TakeDamage

// int32 eid = 1;
inline void TakeDamage::clear_eid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.eid_ = 0;
}
inline ::int32_t TakeDamage::eid() const {
  // @@protoc_insertion_point(field_get:space_service.TakeDamage.eid)
  return _internal_eid();
}
inline void TakeDamage::set_eid(::int32_t value) {
  _internal_set_eid(value);
  // @@protoc_insertion_point(field_set:space_service.TakeDamage.eid)
}
inline ::int32_t TakeDamage::_internal_eid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.eid_;
}
inline void TakeDamage::_internal_set_eid(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.eid_ = value;
}

// int32 damage = 2;
inline void TakeDamage::clear_damage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.damage_ = 0;
}
inline ::int32_t TakeDamage::damage() const {
  // @@protoc_insertion_point(field_get:space_service.TakeDamage.damage)
  return _internal_damage();
}
inline void TakeDamage::set_damage(::int32_t value) {
  _internal_set_damage(value);
  // @@protoc_insertion_point(field_set:space_service.TakeDamage.damage)
}
inline ::int32_t TakeDamage::_internal_damage() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.damage_;
}
inline void TakeDamage::_internal_set_damage(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.damage_ = value;
}

// -------------------------------------------------------------------

// PlayerAttrSet

// int32 eid = 1;
inline void PlayerAttrSet::clear_eid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.eid_ = 0;
}
inline ::int32_t PlayerAttrSet::eid() const {
  // @@protoc_insertion_point(field_get:space_service.PlayerAttrSet.eid)
  return _internal_eid();
}
inline void PlayerAttrSet::set_eid(::int32_t value) {
  _internal_set_eid(value);
  // @@protoc_insertion_point(field_set:space_service.PlayerAttrSet.eid)
}
inline ::int32_t PlayerAttrSet::_internal_eid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.eid_;
}
inline void PlayerAttrSet::_internal_set_eid(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.eid_ = value;
}

// .space_service.AttrSet data = 2;
inline bool PlayerAttrSet::has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.data_ != nullptr);
  return value;
}
inline void PlayerAttrSet::clear_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.data_ != nullptr) _impl_.data_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::space_service::AttrSet& PlayerAttrSet::_internal_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::space_service::AttrSet* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::space_service::AttrSet&>(::space_service::_AttrSet_default_instance_);
}
inline const ::space_service::AttrSet& PlayerAttrSet::data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:space_service.PlayerAttrSet.data)
  return _internal_data();
}
inline void PlayerAttrSet::unsafe_arena_set_allocated_data(::space_service::AttrSet* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = reinterpret_cast<::space_service::AttrSet*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:space_service.PlayerAttrSet.data)
}
inline ::space_service::AttrSet* PlayerAttrSet::release_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::space_service::AttrSet* released = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::space_service::AttrSet* PlayerAttrSet::unsafe_arena_release_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:space_service.PlayerAttrSet.data)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::space_service::AttrSet* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::space_service::AttrSet* PlayerAttrSet::_internal_mutable_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.data_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::space_service::AttrSet>(GetArena());
    _impl_.data_ = reinterpret_cast<::space_service::AttrSet*>(p);
  }
  return _impl_.data_;
}
inline ::space_service::AttrSet* PlayerAttrSet::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::space_service::AttrSet* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:space_service.PlayerAttrSet.data)
  return _msg;
}
inline void PlayerAttrSet::set_allocated_data(::space_service::AttrSet* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.data_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.data_ = reinterpret_cast<::space_service::AttrSet*>(value);
  // @@protoc_insertion_point(field_set_allocated:space_service.PlayerAttrSet.data)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace space_service


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::space_service::Animation_OperationType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::space_service::Animation_OperationType>() {
  return ::space_service::Animation_OperationType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_space_5fservice_2eproto_2epb_2eh
